// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.3.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'api.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `config`, `do_login`, `get_login_config`, `get_phase`, `handle_photostream`, `plist_to_bin`, `plist_to_buf`, `plist_to_string`, `restore`, `setup_push`, `shared_items`, `subscribe_streams`, `wrap_sink`
// These types are ignored because they are not used by any `pub` functions: `FLUTTER_RUST_BRIDGE_HANDLER`, `InnerPushState`, `NSArrayClass`, `NSArrayIconArray`, `NSArrayImageArray`, `SavedHardwareState`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `deref`, `deref`, `eq`, `fmt`, `get_files`, `initialize`, `spawn`

Future<ArcPushState> newPushState({required String dir}) =>
    RustLib.instance.api.crateApiApiNewPushState(dir: dir);

Future<ArcPushState> serviceFromPtr({required String ptr}) =>
    RustLib.instance.api.crateApiApiServiceFromPtr(ptr: ptr);

Future<bool> canFindMy({required ArcPushState state}) =>
    RustLib.instance.api.crateApiApiCanFindMy(state: state);

Future<SupportAlert?> registerIds(
        {required ArcPushState state, required List<IdsUser> users}) =>
    RustLib.instance.api.crateApiApiRegisterIds(state: state, users: users);

Future<void> configureAppReview({required ArcPushState state}) =>
    RustLib.instance.api.crateApiApiConfigureAppReview(state: state);

Future<void> configureMacos(
        {required ArcPushState state, required JoinedOsConfig config}) =>
    RustLib.instance.api
        .crateApiApiConfigureMacos(state: state, config: config);

Future<void> refreshToken({required ArcPushState state}) =>
    RustLib.instance.api.crateApiApiRefreshToken(state: state);

Future<JoinedOsConfig> configFromValidationData(
        {required List<int> data, required HwExtra extra}) =>
    RustLib.instance.api
        .crateApiApiConfigFromValidationData(data: data, extra: extra);

Future<JoinedOsConfig> configFromRelay(
        {required String code, required String host, String? token}) =>
    RustLib.instance.api
        .crateApiApiConfigFromRelay(code: code, host: host, token: token);

Future<String?> validateRelay({required ArcPushState state}) =>
    RustLib.instance.api.crateApiApiValidateRelay(state: state);

Future<DeviceInfo> getDeviceInfoState({required ArcPushState state}) =>
    RustLib.instance.api.crateApiApiGetDeviceInfoState(state: state);

Future<JoinedOsConfig?> getConfigState({required ArcPushState state}) =>
    RustLib.instance.api.crateApiApiGetConfigState(state: state);

Future<DeviceInfo> getDeviceInfo({required JoinedOsConfig config}) =>
    RustLib.instance.api.crateApiApiGetDeviceInfo(config: config);

Future<JoinedOsConfig> configFromEncoded({required List<int> encoded}) =>
    RustLib.instance.api.crateApiApiConfigFromEncoded(encoded: encoded);

Future<PushMessage?> ptrToDart({required String ptr}) =>
    RustLib.instance.api.crateApiApiPtrToDart(ptr: ptr);

Future<void> completeMsg({required String ptr}) =>
    RustLib.instance.api.crateApiApiCompleteMsg(ptr: ptr);

Future<Attachment> restoreAttachment({required String data}) =>
    RustLib.instance.api.crateApiApiRestoreAttachment(data: data);

Future<String> saveAttachment({required Attachment att}) =>
    RustLib.instance.api.crateApiApiSaveAttachment(att: att);

Future<NsArrayLpImageMetadata> createImageArray(
        {required LPImageMetadata img}) =>
    RustLib.instance.api.crateApiApiCreateImageArray(img: img);

Future<NsArrayLpIconMetadata> createIconArray({required LPIconMetadata img}) =>
    RustLib.instance.api.crateApiApiCreateIconArray(img: img);

Future<String> updateAccountHeaders({required ArcPushState state}) =>
    RustLib.instance.api.crateApiApiUpdateAccountHeaders(state: state);

Future<Map<String, String>> getAnisetteHeaders({required ArcPushState state}) =>
    RustLib.instance.api.crateApiApiGetAnisetteHeaders(state: state);

Future<IdsUser> retryLogin({required ArcPushState state}) =>
    RustLib.instance.api.crateApiApiRetryLogin(state: state);

Future<(List<SharedAlbum>, List<String>)> getAlbums(
        {required ArcPushState state, required bool refresh}) =>
    RustLib.instance.api.crateApiApiGetAlbums(state: state, refresh: refresh);

Future<List<SharedAlbum>> subscribe(
        {required ArcPushState state, required String guid}) =>
    RustLib.instance.api.crateApiApiSubscribe(state: state, guid: guid);

Future<List<SharedAlbum>> unsubscribe(
        {required ArcPushState state, required String guid}) =>
    RustLib.instance.api.crateApiApiUnsubscribe(state: state, guid: guid);

Future<List<SharedAlbum>> subscribeToken(
        {required ArcPushState state, required String token}) =>
    RustLib.instance.api.crateApiApiSubscribeToken(state: state, token: token);

Future<List<SharedAlbum>> addAlbum(
        {required ArcPushState state,
        required String guid,
        required String folder}) =>
    RustLib.instance.api
        .crateApiApiAddAlbum(state: state, guid: guid, folder: folder);

Future<List<SharedAlbum>> removeAlbum(
        {required ArcPushState state, required String guid}) =>
    RustLib.instance.api.crateApiApiRemoveAlbum(state: state, guid: guid);

Future<(Map<String, SyncStatus>, (String, BigInt)?)> getSyncstatus(
        {required ArcPushState state}) =>
    RustLib.instance.api.crateApiApiGetSyncstatus(state: state);

Future<void> syncNow({required ArcPushState state}) =>
    RustLib.instance.api.crateApiApiSyncNow(state: state);

Future<bool> supportsSharedStreams({required ArcPushState state}) =>
    RustLib.instance.api.crateApiApiSupportsSharedStreams(state: state);

Future<List<FTSession>> ftSessions({required ArcPushState state}) =>
    RustLib.instance.api.crateApiApiFtSessions(state: state);

Future<String> getFtLink(
        {required ArcPushState state, required String usage}) =>
    RustLib.instance.api.crateApiApiGetFtLink(state: state, usage: usage);

Future<void> useLinkFor(
        {required ArcPushState state,
        required String oldUsage,
        required String usage}) =>
    RustLib.instance.api
        .crateApiApiUseLinkFor(state: state, oldUsage: oldUsage, usage: usage);

Future<void> answerFtRequest(
        {required ArcPushState state,
        required LetMeInRequest request,
        String? approvedGroup}) =>
    RustLib.instance.api.crateApiApiAnswerFtRequest(
        state: state, request: request, approvedGroup: approvedGroup);

Future<void> declineFacetime(
        {required ArcPushState state, required String guid}) =>
    RustLib.instance.api.crateApiApiDeclineFacetime(state: state, guid: guid);

Future<void> createFacetime(
        {required ArcPushState state,
        required String uuid,
        required String handle,
        required List<String> participants}) =>
    RustLib.instance.api.crateApiApiCreateFacetime(
        state: state, uuid: uuid, handle: handle, participants: participants);

Future<void> cancelFacetime(
        {required ArcPushState state, required String guid}) =>
    RustLib.instance.api.crateApiApiCancelFacetime(state: state, guid: guid);

Future<List<String>> validateTargetsFacetime(
        {required ArcPushState state,
        required List<String> targets,
        required String sender}) =>
    RustLib.instance.api.crateApiApiValidateTargetsFacetime(
        state: state, targets: targets, sender: sender);

Future<String> encodeProfileMessage({required ShareProfileMessage p}) =>
    RustLib.instance.api.crateApiApiEncodeProfileMessage(p: p);

Future<ShareProfileMessage> decodeProfileMessage({required String s}) =>
    RustLib.instance.api.crateApiApiDecodeProfileMessage(s: s);

Future<IMessageNicknameRecord> fetchProfile(
        {required ArcPushState state, required ShareProfileMessage message}) =>
    RustLib.instance.api
        .crateApiApiFetchProfile(state: state, message: message);

Future<ShareProfileMessage> setProfile(
        {required ArcPushState state,
        required IMessageNicknameRecord record,
        ShareProfileMessage? existing}) =>
    RustLib.instance.api.crateApiApiSetProfile(
        state: state, record: record, existing: existing);

Future<bool> canProfileShare({required ArcPushState state}) =>
    RustLib.instance.api.crateApiApiCanProfileShare(state: state);

Future<PollResult> recvWait({required ArcPushState state}) =>
    RustLib.instance.api.crateApiApiRecvWait(state: state);

Future<bool> send({required ArcPushState state, required MessageInst msg}) =>
    RustLib.instance.api.crateApiApiSend(state: state, msg: msg);

Future<List<String>> getHandles({required ArcPushState state}) =>
    RustLib.instance.api.crateApiApiGetHandles(state: state);

Future<void> doReregister({required ArcPushState state}) =>
    RustLib.instance.api.crateApiApiDoReregister(state: state);

Future<MessageInst> newMsg(
        {required ArcPushState state,
        required ConversationData conversation,
        required String sender,
        required Message message}) =>
    RustLib.instance.api.crateApiApiNewMsg(
        state: state,
        conversation: conversation,
        sender: sender,
        message: message);

Future<List<String>> validateTargets(
        {required ArcPushState state,
        required List<String> targets,
        required String sender}) =>
    RustLib.instance.api.crateApiApiValidateTargets(
        state: state, targets: targets, sender: sender);

Future<RegistrationPhase> getPhase({required ArcPushState state}) =>
    RustLib.instance.api.crateApiApiGetPhase(state: state);

Stream<TransferProgress> downloadAttachment(
        {required ArcPushState state,
        required Attachment attachment,
        required String path}) =>
    RustLib.instance.api.crateApiApiDownloadAttachment(
        state: state, attachment: attachment, path: path);

Stream<TransferProgress> downloadMmcs(
        {required ArcPushState state,
        required MMCSFile attachment,
        required String path}) =>
    RustLib.instance.api.crateApiApiDownloadMmcs(
        state: state, attachment: attachment, path: path);

Stream<MMCSTransferProgress> uploadMmcs(
        {required ArcPushState state, required String path}) =>
    RustLib.instance.api.crateApiApiUploadMmcs(state: state, path: path);

Stream<TransferProgress> uploadAttachment(
        {required ArcPushState state,
        required String path,
        required String mime,
        required String uti,
        required String name}) =>
    RustLib.instance.api.crateApiApiUploadAttachment(
        state: state, path: path, mime: mime, uti: uti, name: name);

Future<Uint8List> getToken({required ArcPushState state}) =>
    RustLib.instance.api.crateApiApiGetToken(state: state);

Future<String> saveUser({required IdsUser user}) =>
    RustLib.instance.api.crateApiApiSaveUser(user: user);

Future<IdsUser> restoreUser({required String user}) =>
    RustLib.instance.api.crateApiApiRestoreUser(user: user);

Future<FindMyPhoneClientDefaultAnisetteProvider> makeFindMyPhone(
        {required ArcPushState state}) =>
    RustLib.instance.api.crateApiApiMakeFindMyPhone(state: state);

Future<List<FoundDevice>> getDevices(
        {required FindMyPhoneClientDefaultAnisetteProvider client}) =>
    RustLib.instance.api.crateApiApiGetDevices(client: client);

Future<List<FoundDevice>> refreshDevices(
        {required ArcPushState state,
        required FindMyPhoneClientDefaultAnisetteProvider client}) =>
    RustLib.instance.api
        .crateApiApiRefreshDevices(state: state, client: client);

Future<FindMyFriendsClientDefaultAnisetteProvider> makeFindMyFriends(
        {required ArcPushState state}) =>
    RustLib.instance.api.crateApiApiMakeFindMyFriends(state: state);

Future<List<Follow>> getFollowing(
        {required FindMyFriendsClientDefaultAnisetteProvider client}) =>
    RustLib.instance.api.crateApiApiGetFollowing(client: client);

Future<List<Follow>> refreshFollowing(
        {required ArcPushState state,
        required FindMyFriendsClientDefaultAnisetteProvider client}) =>
    RustLib.instance.api
        .crateApiApiRefreshFollowing(state: state, client: client);

Future<List<Follow>> selectFriend(
        {required ArcPushState state,
        required FindMyFriendsClientDefaultAnisetteProvider client,
        String? friend}) =>
    RustLib.instance.api
        .crateApiApiSelectFriend(state: state, client: client, friend: friend);

Future<List<Follow>> selectBackgroundFriend(
        {required ArcPushState state, String? friend}) =>
    RustLib.instance.api
        .crateApiApiSelectBackgroundFriend(state: state, friend: friend);

Future<List<Follow>> getBackgroundFollowing({required ArcPushState state}) =>
    RustLib.instance.api.crateApiApiGetBackgroundFollowing(state: state);

Future<List<Follow>> refreshBackgroundFollowing(
        {required ArcPushState state}) =>
    RustLib.instance.api.crateApiApiRefreshBackgroundFollowing(state: state);

Future<(LoginState, IdsUser?)> tryAuth(
        {required ArcPushState state,
        required String username,
        required String password}) =>
    RustLib.instance.api.crateApiApiTryAuth(
        state: state, username: username, password: password);

Future<IdsUser> authPhone(
        {required ArcPushState state,
        required String number,
        required List<int> sig}) =>
    RustLib.instance.api
        .crateApiApiAuthPhone(state: state, number: number, sig: sig);

Future<LoginState> send2FaToDevices({required ArcPushState state}) =>
    RustLib.instance.api.crateApiApiSend2FaToDevices(state: state);

Future<(LoginState, IdsUser?)> verify2Fa(
        {required ArcPushState state, required String code}) =>
    RustLib.instance.api.crateApiApiVerify2Fa(state: state, code: code);

Future<(List<TrustedPhoneNumber>, LoginState?)> get2FaSmsOpts(
        {required ArcPushState state}) =>
    RustLib.instance.api.crateApiApiGet2FaSmsOpts(state: state);

Future<LoginState> send2FaSms(
        {required ArcPushState state, required int phoneId}) =>
    RustLib.instance.api.crateApiApiSend2FaSms(state: state, phoneId: phoneId);

Future<(LoginState, IdsUser?)> verify2FaSms(
        {required ArcPushState state,
        required VerifyBody body,
        required String code}) =>
    RustLib.instance.api
        .crateApiApiVerify2FaSms(state: state, body: body, code: code);

Future<List<String>> validateCert(
        {required ArcPushState state, required IdsUser user}) =>
    RustLib.instance.api.crateApiApiValidateCert(state: state, user: user);

Future<void> resetState({required ArcPushState state, required bool resetHw}) =>
    RustLib.instance.api.crateApiApiResetState(state: state, resetHw: resetHw);

Future<void> invalidateIdCache({required ArcPushState state}) =>
    RustLib.instance.api.crateApiApiInvalidateIdCache(state: state);

Future<String> getUserName({required ArcPushState state}) =>
    RustLib.instance.api.crateApiApiGetUserName(state: state);

Future<RegisterState> getRegstate({required ArcPushState state}) =>
    RustLib.instance.api.crateApiApiGetRegstate(state: state);

Future<String> convertTokenToUuid(
        {required ArcPushState state,
        required String handle,
        required List<int> token}) =>
    RustLib.instance.api.crateApiApiConvertTokenToUuid(
        state: state, handle: handle, token: token);

Future<List<PrivateDeviceInfo>> getSmsTargets(
        {required ArcPushState state,
        required String handle,
        required bool refresh}) =>
    RustLib.instance.api.crateApiApiGetSmsTargets(
        state: state, handle: handle, refresh: refresh);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConversationLink>>
abstract class ConversationLink implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConversationParticipant>>
abstract class ConversationParticipant implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FindMyFriendsClient < DefaultAnisetteProvider >>>
abstract class FindMyFriendsClientDefaultAnisetteProvider
    implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FindMyPhoneClient < DefaultAnisetteProvider >>>
abstract class FindMyPhoneClientDefaultAnisetteProvider
    implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<IDSUser>>
abstract class IdsUser implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<JoinedOSConfig>>
abstract class JoinedOsConfig implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VerifyBody>>
abstract class VerifyBody implements RustOpaqueInterface {}

class Address {
  final String? administrativeArea;
  final String country;
  final String countryCode;
  final List<String>? formattedAddressLines;
  final String? locality;
  final String? stateCode;
  final String? streetAddress;
  final String? streetName;

  const Address({
    this.administrativeArea,
    required this.country,
    required this.countryCode,
    this.formattedAddressLines,
    this.locality,
    this.stateCode,
    this.streetAddress,
    this.streetName,
  });

  @override
  int get hashCode =>
      administrativeArea.hashCode ^
      country.hashCode ^
      countryCode.hashCode ^
      formattedAddressLines.hashCode ^
      locality.hashCode ^
      stateCode.hashCode ^
      streetAddress.hashCode ^
      streetName.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Address &&
          runtimeType == other.runtimeType &&
          administrativeArea == other.administrativeArea &&
          country == other.country &&
          countryCode == other.countryCode &&
          formattedAddressLines == other.formattedAddressLines &&
          locality == other.locality &&
          stateCode == other.stateCode &&
          streetAddress == other.streetAddress &&
          streetName == other.streetName;
}

class Attachment {
  final AttachmentType aType;
  final int part_;
  final String utiType;
  final String mime;
  final String name;
  final bool iris;

  const Attachment({
    required this.aType,
    required this.part_,
    required this.utiType,
    required this.mime,
    required this.name,
    required this.iris,
  });

  Future<int> getSize() => RustLib.instance.api.crateApiApiAttachmentGetSize(
        that: this,
      );

  @override
  int get hashCode =>
      aType.hashCode ^
      part_.hashCode ^
      utiType.hashCode ^
      mime.hashCode ^
      name.hashCode ^
      iris.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Attachment &&
          runtimeType == other.runtimeType &&
          aType == other.aType &&
          part_ == other.part_ &&
          utiType == other.utiType &&
          mime == other.mime &&
          name == other.name &&
          iris == other.iris;
}

@freezed
sealed class AttachmentType with _$AttachmentType {
  const AttachmentType._();

  const factory AttachmentType.inline(
    Uint8List field0,
  ) = AttachmentType_Inline;
  const factory AttachmentType.mmcs(
    MMCSFile field0,
  ) = AttachmentType_MMCS;
}

class Balloon {
  final String url;
  final String? session;
  final BalloonLayout layout;
  final String? ldText;
  final bool isLive;
  final Uint8List icon;

  const Balloon({
    required this.url,
    this.session,
    required this.layout,
    this.ldText,
    required this.isLive,
    required this.icon,
  });

  @override
  int get hashCode =>
      url.hashCode ^
      session.hashCode ^
      layout.hashCode ^
      ldText.hashCode ^
      isLive.hashCode ^
      icon.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Balloon &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          session == other.session &&
          layout == other.layout &&
          ldText == other.ldText &&
          isLive == other.isLive &&
          icon == other.icon;
}

@freezed
sealed class BalloonLayout with _$BalloonLayout {
  const BalloonLayout._();

  const factory BalloonLayout.templateLayout({
    required String imageSubtitle,
    required String imageTitle,
    required String caption,
    required String secondarySubcaption,
    required String tertiarySubcaption,
    required String subcaption,
    required NSDictionaryClass class_,
  }) = BalloonLayout_TemplateLayout;
}

class ChangeParticipantMessage {
  final List<String> newParticipants;
  final int groupVersion;

  const ChangeParticipantMessage({
    required this.newParticipants,
    required this.groupVersion,
  });

  @override
  int get hashCode => newParticipants.hashCode ^ groupVersion.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChangeParticipantMessage &&
          runtimeType == other.runtimeType &&
          newParticipants == other.newParticipants &&
          groupVersion == other.groupVersion;
}

class ConversationData {
  List<String> participants;
  String? cvName;
  String? senderGuid;
  String? afterGuid;

  ConversationData({
    required this.participants,
    this.cvName,
    this.senderGuid,
    this.afterGuid,
  });

  @override
  int get hashCode =>
      participants.hashCode ^
      cvName.hashCode ^
      senderGuid.hashCode ^
      afterGuid.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConversationData &&
          runtimeType == other.runtimeType &&
          participants == other.participants &&
          cvName == other.cvName &&
          senderGuid == other.senderGuid &&
          afterGuid == other.afterGuid;
}

@freezed
sealed class DeleteTarget with _$DeleteTarget {
  const DeleteTarget._();

  const factory DeleteTarget.chat(
    OperatedChat field0,
  ) = DeleteTarget_Chat;
  const factory DeleteTarget.messages(
    List<String> field0,
  ) = DeleteTarget_Messages;
}

class DeviceInfo {
  final String name;
  final String serial;
  final String osVersion;
  final Uint8List? encodedData;

  const DeviceInfo({
    required this.name,
    required this.serial,
    required this.osVersion,
    this.encodedData,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      serial.hashCode ^
      osVersion.hashCode ^
      encodedData.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DeviceInfo &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          serial == other.serial &&
          osVersion == other.osVersion &&
          encodedData == other.encodedData;
}

class EditMessage {
  final String tuuid;
  final int editPart;
  final MessageParts newParts;

  const EditMessage({
    required this.tuuid,
    required this.editPart,
    required this.newParts,
  });

  @override
  int get hashCode => tuuid.hashCode ^ editPart.hashCode ^ newParts.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EditMessage &&
          runtimeType == other.runtimeType &&
          tuuid == other.tuuid &&
          editPart == other.editPart &&
          newParts == other.newParts;
}

class ErrorMessage {
  final String forUuid;
  final BigInt status;
  final String statusStr;

  const ErrorMessage({
    required this.forUuid,
    required this.status,
    required this.statusStr,
  });

  @override
  int get hashCode => forUuid.hashCode ^ status.hashCode ^ statusStr.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ErrorMessage &&
          runtimeType == other.runtimeType &&
          forUuid == other.forUuid &&
          status == other.status &&
          statusStr == other.statusStr;
}

class ExtensionApp {
  final String name;
  final int? appId;
  final String bundleId;
  final Balloon? balloon;

  const ExtensionApp({
    required this.name,
    this.appId,
    required this.bundleId,
    this.balloon,
  });

  @override
  int get hashCode =>
      name.hashCode ^ appId.hashCode ^ bundleId.hashCode ^ balloon.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ExtensionApp &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          appId == other.appId &&
          bundleId == other.bundleId &&
          balloon == other.balloon;
}

class FFIFilePackager {
  const FFIFilePackager();

  static Future<FFIFilePackager> default_() =>
      RustLib.instance.api.crateApiApiFfiFilePackagerDefault();

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FFIFilePackager && runtimeType == other.runtimeType;
}

class Follow {
  final PlatformInt64 createTimestamp;
  final PlatformInt64 expires;
  final String id;
  final List<String> invitationAcceptedHandles;
  final List<String> invitationFromHandles;
  final bool isFromMessages;
  final String? offerId;
  final bool onlyInEvent;
  final String personIdHash;
  final bool secureLocationsCapable;
  final bool shallowOrLiveSecureLocationsCapable;
  final String source;
  final bool tkPermission;
  final PlatformInt64 updateTimestamp;
  final bool? fallbackToLegacyAllowed;
  final bool? optedNotToShare;
  final Location? lastLocation;
  final bool locateInProgress;

  const Follow({
    required this.createTimestamp,
    required this.expires,
    required this.id,
    required this.invitationAcceptedHandles,
    required this.invitationFromHandles,
    required this.isFromMessages,
    this.offerId,
    required this.onlyInEvent,
    required this.personIdHash,
    required this.secureLocationsCapable,
    required this.shallowOrLiveSecureLocationsCapable,
    required this.source,
    required this.tkPermission,
    required this.updateTimestamp,
    this.fallbackToLegacyAllowed,
    this.optedNotToShare,
    this.lastLocation,
    required this.locateInProgress,
  });

  @override
  int get hashCode =>
      createTimestamp.hashCode ^
      expires.hashCode ^
      id.hashCode ^
      invitationAcceptedHandles.hashCode ^
      invitationFromHandles.hashCode ^
      isFromMessages.hashCode ^
      offerId.hashCode ^
      onlyInEvent.hashCode ^
      personIdHash.hashCode ^
      secureLocationsCapable.hashCode ^
      shallowOrLiveSecureLocationsCapable.hashCode ^
      source.hashCode ^
      tkPermission.hashCode ^
      updateTimestamp.hashCode ^
      fallbackToLegacyAllowed.hashCode ^
      optedNotToShare.hashCode ^
      lastLocation.hashCode ^
      locateInProgress.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Follow &&
          runtimeType == other.runtimeType &&
          createTimestamp == other.createTimestamp &&
          expires == other.expires &&
          id == other.id &&
          invitationAcceptedHandles == other.invitationAcceptedHandles &&
          invitationFromHandles == other.invitationFromHandles &&
          isFromMessages == other.isFromMessages &&
          offerId == other.offerId &&
          onlyInEvent == other.onlyInEvent &&
          personIdHash == other.personIdHash &&
          secureLocationsCapable == other.secureLocationsCapable &&
          shallowOrLiveSecureLocationsCapable ==
              other.shallowOrLiveSecureLocationsCapable &&
          source == other.source &&
          tkPermission == other.tkPermission &&
          updateTimestamp == other.updateTimestamp &&
          fallbackToLegacyAllowed == other.fallbackToLegacyAllowed &&
          optedNotToShare == other.optedNotToShare &&
          lastLocation == other.lastLocation &&
          locateInProgress == other.locateInProgress;
}

class FoundDevice {
  final String? deviceModel;
  final bool? lowPowerMode;
  final PlatformInt64? passcodeLength;
  final String? id;
  final String? batteryStatus;
  final bool? lostModeCapable;
  final double? batteryLevel;
  final bool? locationEnabled;
  final bool? isConsideredAccessory;
  final Location? location;
  final String? modelDisplayName;
  final String? deviceColor;
  final bool? activationLocked;
  final PlatformInt64? rm2State;
  final bool? locFoundEnabled;
  final bool? nwd;
  final String? deviceStatus;
  final bool? fmlyShare;
  final Map<String, bool> features;
  final bool? thisDevice;
  final bool? lostModeEnabled;
  final String? deviceDisplayName;
  final String? name;
  final bool? canWipeAfterLock;
  final bool? isMac;
  final String? rawDeviceModel;
  final String? baUuid;
  final String? deviceDiscoveryId;
  final bool? scd;
  final bool? locationCapable;
  final bool? wipeInProgress;
  final bool? darkWake;
  final bool? deviceWithYou;
  final PlatformInt64? maxMsgChar;
  final String? deviceClass;

  const FoundDevice({
    this.deviceModel,
    this.lowPowerMode,
    this.passcodeLength,
    this.id,
    this.batteryStatus,
    this.lostModeCapable,
    this.batteryLevel,
    this.locationEnabled,
    this.isConsideredAccessory,
    this.location,
    this.modelDisplayName,
    this.deviceColor,
    this.activationLocked,
    this.rm2State,
    this.locFoundEnabled,
    this.nwd,
    this.deviceStatus,
    this.fmlyShare,
    required this.features,
    this.thisDevice,
    this.lostModeEnabled,
    this.deviceDisplayName,
    this.name,
    this.canWipeAfterLock,
    this.isMac,
    this.rawDeviceModel,
    this.baUuid,
    this.deviceDiscoveryId,
    this.scd,
    this.locationCapable,
    this.wipeInProgress,
    this.darkWake,
    this.deviceWithYou,
    this.maxMsgChar,
    this.deviceClass,
  });

  @override
  int get hashCode =>
      deviceModel.hashCode ^
      lowPowerMode.hashCode ^
      passcodeLength.hashCode ^
      id.hashCode ^
      batteryStatus.hashCode ^
      lostModeCapable.hashCode ^
      batteryLevel.hashCode ^
      locationEnabled.hashCode ^
      isConsideredAccessory.hashCode ^
      location.hashCode ^
      modelDisplayName.hashCode ^
      deviceColor.hashCode ^
      activationLocked.hashCode ^
      rm2State.hashCode ^
      locFoundEnabled.hashCode ^
      nwd.hashCode ^
      deviceStatus.hashCode ^
      fmlyShare.hashCode ^
      features.hashCode ^
      thisDevice.hashCode ^
      lostModeEnabled.hashCode ^
      deviceDisplayName.hashCode ^
      name.hashCode ^
      canWipeAfterLock.hashCode ^
      isMac.hashCode ^
      rawDeviceModel.hashCode ^
      baUuid.hashCode ^
      deviceDiscoveryId.hashCode ^
      scd.hashCode ^
      locationCapable.hashCode ^
      wipeInProgress.hashCode ^
      darkWake.hashCode ^
      deviceWithYou.hashCode ^
      maxMsgChar.hashCode ^
      deviceClass.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FoundDevice &&
          runtimeType == other.runtimeType &&
          deviceModel == other.deviceModel &&
          lowPowerMode == other.lowPowerMode &&
          passcodeLength == other.passcodeLength &&
          id == other.id &&
          batteryStatus == other.batteryStatus &&
          lostModeCapable == other.lostModeCapable &&
          batteryLevel == other.batteryLevel &&
          locationEnabled == other.locationEnabled &&
          isConsideredAccessory == other.isConsideredAccessory &&
          location == other.location &&
          modelDisplayName == other.modelDisplayName &&
          deviceColor == other.deviceColor &&
          activationLocked == other.activationLocked &&
          rm2State == other.rm2State &&
          locFoundEnabled == other.locFoundEnabled &&
          nwd == other.nwd &&
          deviceStatus == other.deviceStatus &&
          fmlyShare == other.fmlyShare &&
          features == other.features &&
          thisDevice == other.thisDevice &&
          lostModeEnabled == other.lostModeEnabled &&
          deviceDisplayName == other.deviceDisplayName &&
          name == other.name &&
          canWipeAfterLock == other.canWipeAfterLock &&
          isMac == other.isMac &&
          rawDeviceModel == other.rawDeviceModel &&
          baUuid == other.baUuid &&
          deviceDiscoveryId == other.deviceDiscoveryId &&
          scd == other.scd &&
          locationCapable == other.locationCapable &&
          wipeInProgress == other.wipeInProgress &&
          darkWake == other.darkWake &&
          deviceWithYou == other.deviceWithYou &&
          maxMsgChar == other.maxMsgChar &&
          deviceClass == other.deviceClass;
}

class FTMember {
  final String? nickname;
  final String handle;

  const FTMember({
    this.nickname,
    required this.handle,
  });

  @override
  int get hashCode => nickname.hashCode ^ handle.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FTMember &&
          runtimeType == other.runtimeType &&
          nickname == other.nickname &&
          handle == other.handle;
}

@freezed
sealed class FTMessage with _$FTMessage {
  const FTMessage._();

  const factory FTMessage.letMeInRequest(
    LetMeInRequest field0,
  ) = FTMessage_LetMeInRequest;
  const factory FTMessage.linkChanged({
    required String guid,
  }) = FTMessage_LinkChanged;
  const factory FTMessage.joinEvent({
    required String guid,
    required BigInt participant,
    required String handle,
    required bool ring,
  }) = FTMessage_JoinEvent;
  const factory FTMessage.addMembers({
    required String guid,
    required Set<FTMember> members,
    required bool ring,
  }) = FTMessage_AddMembers;
  const factory FTMessage.removeMembers({
    required String guid,
    required Set<FTMember> members,
  }) = FTMessage_RemoveMembers;
  const factory FTMessage.leaveEvent({
    required String guid,
    required BigInt participant,
    required String handle,
  }) = FTMessage_LeaveEvent;
  const factory FTMessage.ring({
    required String guid,
  }) = FTMessage_Ring;
  const factory FTMessage.decline({
    required String guid,
  }) = FTMessage_Decline;
  const factory FTMessage.respondedElsewhere({
    required String guid,
  }) = FTMessage_RespondedElsewhere;
}

enum FTMode {
  outgoing,
  incoming,
  missed,
  missedOutgoing,
  ;
}

class FTParticipant {
  final String? token;
  final String handle;
  final int participantId;
  final int? lastJoinDate;
  final ConversationParticipant? active;

  const FTParticipant({
    this.token,
    required this.handle,
    required this.participantId,
    this.lastJoinDate,
    this.active,
  });

  @override
  int get hashCode =>
      token.hashCode ^
      handle.hashCode ^
      participantId.hashCode ^
      lastJoinDate.hashCode ^
      active.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FTParticipant &&
          runtimeType == other.runtimeType &&
          token == other.token &&
          handle == other.handle &&
          participantId == other.participantId &&
          lastJoinDate == other.lastJoinDate &&
          active == other.active;
}

class FTSession {
  final String groupId;
  final List<String> myHandles;
  final Map<String, FTParticipant> participants;
  final ConversationLink? link;
  final Set<FTMember> members;
  final String reportId;
  final int? startTime;
  final int? lastRekey;
  final bool isPropped;
  final bool isRingingInaccurate;
  final FTMode? mode;
  final Map<String, int> recentMemberAdds;

  const FTSession({
    required this.groupId,
    required this.myHandles,
    required this.participants,
    this.link,
    required this.members,
    required this.reportId,
    this.startTime,
    this.lastRekey,
    required this.isPropped,
    required this.isRingingInaccurate,
    this.mode,
    required this.recentMemberAdds,
  });

  @override
  int get hashCode =>
      groupId.hashCode ^
      myHandles.hashCode ^
      participants.hashCode ^
      link.hashCode ^
      members.hashCode ^
      reportId.hashCode ^
      startTime.hashCode ^
      lastRekey.hashCode ^
      isPropped.hashCode ^
      isRingingInaccurate.hashCode ^
      mode.hashCode ^
      recentMemberAdds.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FTSession &&
          runtimeType == other.runtimeType &&
          groupId == other.groupId &&
          myHandles == other.myHandles &&
          participants == other.participants &&
          link == other.link &&
          members == other.members &&
          reportId == other.reportId &&
          startTime == other.startTime &&
          lastRekey == other.lastRekey &&
          isPropped == other.isPropped &&
          isRingingInaccurate == other.isRingingInaccurate &&
          mode == other.mode &&
          recentMemberAdds == other.recentMemberAdds;
}

class HwExtra {
  final String version;
  final int protocolVersion;
  final String deviceId;
  final String icloudUa;
  final String aoskitVersion;

  const HwExtra({
    required this.version,
    required this.protocolVersion,
    required this.deviceId,
    required this.icloudUa,
    required this.aoskitVersion,
  });

  @override
  int get hashCode =>
      version.hashCode ^
      protocolVersion.hashCode ^
      deviceId.hashCode ^
      icloudUa.hashCode ^
      aoskitVersion.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is HwExtra &&
          runtimeType == other.runtimeType &&
          version == other.version &&
          protocolVersion == other.protocolVersion &&
          deviceId == other.deviceId &&
          icloudUa == other.icloudUa &&
          aoskitVersion == other.aoskitVersion;
}

class IMessageNameRecord {
  final String name;
  final String first;
  final String last;

  const IMessageNameRecord({
    required this.name,
    required this.first,
    required this.last,
  });

  @override
  int get hashCode => name.hashCode ^ first.hashCode ^ last.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is IMessageNameRecord &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          first == other.first &&
          last == other.last;
}

class IMessageNicknameRecord {
  final IMessageNameRecord name;
  final Uint8List? image;
  final IMessagePosterRecord? poster;

  const IMessageNicknameRecord({
    required this.name,
    this.image,
    this.poster,
  });

  @override
  int get hashCode => name.hashCode ^ image.hashCode ^ poster.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is IMessageNicknameRecord &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          image == other.image &&
          poster == other.poster;
}

class IMessagePosterRecord {
  final Uint8List lowResPoster;
  final Uint8List package;
  final Uint8List meta;

  const IMessagePosterRecord({
    required this.lowResPoster,
    required this.package,
    required this.meta,
  });

  @override
  int get hashCode => lowResPoster.hashCode ^ package.hashCode ^ meta.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is IMessagePosterRecord &&
          runtimeType == other.runtimeType &&
          lowResPoster == other.lowResPoster &&
          package == other.package &&
          meta == other.meta;
}

class IconChangeMessage {
  final MMCSFile? file;
  final int groupVersion;

  const IconChangeMessage({
    this.file,
    required this.groupVersion,
  });

  @override
  int get hashCode => file.hashCode ^ groupVersion.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is IconChangeMessage &&
          runtimeType == other.runtimeType &&
          file == other.file &&
          groupVersion == other.groupVersion;
}

class IndexedMessagePart {
  final MessagePart part_;
  final int? idx;
  final PartExtension? ext;

  const IndexedMessagePart({
    required this.part_,
    this.idx,
    this.ext,
  });

  @override
  int get hashCode => part_.hashCode ^ idx.hashCode ^ ext.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is IndexedMessagePart &&
          runtimeType == other.runtimeType &&
          part_ == other.part_ &&
          idx == other.idx &&
          ext == other.ext;
}

class LetMeInRequest {
  final Uint8List sharedSecret;
  final String pseud;
  final String requestor;
  final String? nickname;
  final Uint8List token;
  final String? delegationUuid;
  final String? usage;

  const LetMeInRequest({
    required this.sharedSecret,
    required this.pseud,
    required this.requestor,
    this.nickname,
    required this.token,
    this.delegationUuid,
    this.usage,
  });

  @override
  int get hashCode =>
      sharedSecret.hashCode ^
      pseud.hashCode ^
      requestor.hashCode ^
      nickname.hashCode ^
      token.hashCode ^
      delegationUuid.hashCode ^
      usage.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LetMeInRequest &&
          runtimeType == other.runtimeType &&
          sharedSecret == other.sharedSecret &&
          pseud == other.pseud &&
          requestor == other.requestor &&
          nickname == other.nickname &&
          token == other.token &&
          delegationUuid == other.delegationUuid &&
          usage == other.usage;
}

class LinkMeta {
  final LPLinkMetadata data;
  final List<Uint8List> attachments;

  const LinkMeta({
    required this.data,
    required this.attachments,
  });

  @override
  int get hashCode => data.hashCode ^ attachments.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LinkMeta &&
          runtimeType == other.runtimeType &&
          data == other.data &&
          attachments == other.attachments;
}

class Location {
  final Address? address;
  final double altitude;
  final PlatformInt64 floorLevel;
  final double horizontalAccuracy;
  final bool isInaccurate;
  final double latitude;
  final String? locationId;
  final PlatformInt64? locationTimestamp;
  final double longitude;
  final PlatformInt64 secureLocationTs;
  final PlatformInt64 timestamp;
  final double verticalAccuracy;
  final String? positionType;
  final bool? isOld;
  final bool? locationFinished;

  const Location({
    this.address,
    required this.altitude,
    required this.floorLevel,
    required this.horizontalAccuracy,
    required this.isInaccurate,
    required this.latitude,
    this.locationId,
    this.locationTimestamp,
    required this.longitude,
    required this.secureLocationTs,
    required this.timestamp,
    required this.verticalAccuracy,
    this.positionType,
    this.isOld,
    this.locationFinished,
  });

  @override
  int get hashCode =>
      address.hashCode ^
      altitude.hashCode ^
      floorLevel.hashCode ^
      horizontalAccuracy.hashCode ^
      isInaccurate.hashCode ^
      latitude.hashCode ^
      locationId.hashCode ^
      locationTimestamp.hashCode ^
      longitude.hashCode ^
      secureLocationTs.hashCode ^
      timestamp.hashCode ^
      verticalAccuracy.hashCode ^
      positionType.hashCode ^
      isOld.hashCode ^
      locationFinished.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Location &&
          runtimeType == other.runtimeType &&
          address == other.address &&
          altitude == other.altitude &&
          floorLevel == other.floorLevel &&
          horizontalAccuracy == other.horizontalAccuracy &&
          isInaccurate == other.isInaccurate &&
          latitude == other.latitude &&
          locationId == other.locationId &&
          locationTimestamp == other.locationTimestamp &&
          longitude == other.longitude &&
          secureLocationTs == other.secureLocationTs &&
          timestamp == other.timestamp &&
          verticalAccuracy == other.verticalAccuracy &&
          positionType == other.positionType &&
          isOld == other.isOld &&
          locationFinished == other.locationFinished;
}

@freezed
sealed class LoginState with _$LoginState {
  const LoginState._();

  const factory LoginState.loggedIn() = LoginState_LoggedIn;
  const factory LoginState.needsDevice2Fa() = LoginState_NeedsDevice2FA;
  const factory LoginState.needs2FaVerification() =
      LoginState_Needs2FAVerification;
  const factory LoginState.needsSms2Fa() = LoginState_NeedsSMS2FA;
  const factory LoginState.needsSms2FaVerification(
    VerifyBody field0,
  ) = LoginState_NeedsSMS2FAVerification;
  const factory LoginState.needsExtraStep(
    String field0,
  ) = LoginState_NeedsExtraStep;
  const factory LoginState.needsLogin() = LoginState_NeedsLogin;
}

class LPIconMetadata {
  final NSURL url;
  final int version;

  const LPIconMetadata({
    required this.url,
    required this.version,
  });

  @override
  int get hashCode => url.hashCode ^ version.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LPIconMetadata &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          version == other.version;
}

class LPImageMetadata {
  final String size;
  final NSURL url;
  final int version;

  const LPImageMetadata({
    required this.size,
    required this.url,
    required this.version,
  });

  @override
  int get hashCode => size.hashCode ^ url.hashCode ^ version.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LPImageMetadata &&
          runtimeType == other.runtimeType &&
          size == other.size &&
          url == other.url &&
          version == other.version;
}

class LPLinkMetadata {
  final LPImageMetadata? imageMetadata;
  final int version;
  final LPIconMetadata? iconMetadata;
  final NSURL originalUrl;
  final NSURL? url;
  final String? title;
  final String? summary;
  final RichLinkImageAttachmentSubstitute? image;
  final RichLinkImageAttachmentSubstitute? icon;
  final NsArrayLpImageMetadata? images;
  final NsArrayLpIconMetadata? icons;

  const LPLinkMetadata({
    this.imageMetadata,
    required this.version,
    this.iconMetadata,
    required this.originalUrl,
    this.url,
    this.title,
    this.summary,
    this.image,
    this.icon,
    this.images,
    this.icons,
  });

  @override
  int get hashCode =>
      imageMetadata.hashCode ^
      version.hashCode ^
      iconMetadata.hashCode ^
      originalUrl.hashCode ^
      url.hashCode ^
      title.hashCode ^
      summary.hashCode ^
      image.hashCode ^
      icon.hashCode ^
      images.hashCode ^
      icons.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LPLinkMetadata &&
          runtimeType == other.runtimeType &&
          imageMetadata == other.imageMetadata &&
          version == other.version &&
          iconMetadata == other.iconMetadata &&
          originalUrl == other.originalUrl &&
          url == other.url &&
          title == other.title &&
          summary == other.summary &&
          image == other.image &&
          icon == other.icon &&
          images == other.images &&
          icons == other.icons;
}

@freezed
sealed class Message with _$Message {
  const Message._();

  const factory Message.message(
    NormalMessage field0,
  ) = Message_Message;
  const factory Message.renameMessage(
    RenameMessage field0,
  ) = Message_RenameMessage;
  const factory Message.changeParticipants(
    ChangeParticipantMessage field0,
  ) = Message_ChangeParticipants;
  const factory Message.react(
    ReactMessage field0,
  ) = Message_React;
  const factory Message.delivered() = Message_Delivered;
  const factory Message.read() = Message_Read;
  const factory Message.typing() = Message_Typing;
  const factory Message.unsend(
    UnsendMessage field0,
  ) = Message_Unsend;
  const factory Message.edit(
    EditMessage field0,
  ) = Message_Edit;
  const factory Message.iconChange(
    IconChangeMessage field0,
  ) = Message_IconChange;
  const factory Message.stopTyping() = Message_StopTyping;
  const factory Message.enableSmsActivation(
    bool field0,
  ) = Message_EnableSmsActivation;
  const factory Message.messageReadOnDevice() = Message_MessageReadOnDevice;
  const factory Message.smsConfirmSent(
    bool field0,
  ) = Message_SmsConfirmSent;
  const factory Message.markUnread() = Message_MarkUnread;
  const factory Message.peerCacheInvalidate() = Message_PeerCacheInvalidate;
  const factory Message.updateExtension(
    UpdateExtensionMessage field0,
  ) = Message_UpdateExtension;
  const factory Message.error(
    ErrorMessage field0,
  ) = Message_Error;
  const factory Message.moveToRecycleBin(
    MoveToRecycleBinMessage field0,
  ) = Message_MoveToRecycleBin;
  const factory Message.recoverChat(
    OperatedChat field0,
  ) = Message_RecoverChat;
  const factory Message.permanentDelete(
    PermanentDeleteMessage field0,
  ) = Message_PermanentDelete;
  const factory Message.unschedule() = Message_Unschedule;
  const factory Message.updateProfile(
    UpdateProfileMessage field0,
  ) = Message_UpdateProfile;
  const factory Message.updateProfileSharing(
    UpdateProfileSharingMessage field0,
  ) = Message_UpdateProfileSharing;
  const factory Message.shareProfile(
    ShareProfileMessage field0,
  ) = Message_ShareProfile;
}

class MessageInst {
  String id;
  String? sender;
  ConversationData? conversation;
  Message message;
  int sentTimestamp;
  List<MessageTarget>? target;
  bool sendDelivered;
  bool verificationFailed;

  MessageInst({
    required this.id,
    this.sender,
    this.conversation,
    required this.message,
    required this.sentTimestamp,
    this.target,
    required this.sendDelivered,
    required this.verificationFailed,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      sender.hashCode ^
      conversation.hashCode ^
      message.hashCode ^
      sentTimestamp.hashCode ^
      target.hashCode ^
      sendDelivered.hashCode ^
      verificationFailed.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MessageInst &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          sender == other.sender &&
          conversation == other.conversation &&
          message == other.message &&
          sentTimestamp == other.sentTimestamp &&
          target == other.target &&
          sendDelivered == other.sendDelivered &&
          verificationFailed == other.verificationFailed;
}

@freezed
sealed class MessagePart with _$MessagePart {
  const MessagePart._();

  const factory MessagePart.text(
    String field0,
    TextFormat field1,
  ) = MessagePart_Text;
  const factory MessagePart.attachment(
    Attachment field0,
  ) = MessagePart_Attachment;
  const factory MessagePart.mention(
    String field0,
    String field1,
  ) = MessagePart_Mention;
  const factory MessagePart.object(
    String field0,
  ) = MessagePart_Object;
}

class MessageParts {
  final List<IndexedMessagePart> field0;

  const MessageParts({
    required this.field0,
  });

  Future<String> rawText() =>
      RustLib.instance.api.crateApiApiMessagePartsRawText(
        that: this,
      );

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MessageParts &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

@freezed
sealed class MessageTarget with _$MessageTarget {
  const MessageTarget._();

  const factory MessageTarget.token(
    Uint8List field0,
  ) = MessageTarget_Token;
  const factory MessageTarget.uuid(
    String field0,
  ) = MessageTarget_Uuid;
}

@freezed
sealed class MessageType with _$MessageType {
  const MessageType._();

  const factory MessageType.iMessage() = MessageType_IMessage;
  const factory MessageType.sms({
    required bool isPhone,
    required String usingNumber,
    String? fromHandle,
  }) = MessageType_SMS;
}

class MMCSFile {
  final Uint8List signature;
  final String object;
  final String url;
  final Uint8List key;
  final int size;

  const MMCSFile({
    required this.signature,
    required this.object,
    required this.url,
    required this.key,
    required this.size,
  });

  @override
  int get hashCode =>
      signature.hashCode ^
      object.hashCode ^
      url.hashCode ^
      key.hashCode ^
      size.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MMCSFile &&
          runtimeType == other.runtimeType &&
          signature == other.signature &&
          object == other.object &&
          url == other.url &&
          key == other.key &&
          size == other.size;
}

class MMCSTransferProgress {
  final int prog;
  final int total;
  final MMCSFile? file;

  const MMCSTransferProgress({
    required this.prog,
    required this.total,
    this.file,
  });

  @override
  int get hashCode => prog.hashCode ^ total.hashCode ^ file.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MMCSTransferProgress &&
          runtimeType == other.runtimeType &&
          prog == other.prog &&
          total == other.total &&
          file == other.file;
}

class MoveToRecycleBinMessage {
  final DeleteTarget target;
  final int recoverableDeleteDate;

  const MoveToRecycleBinMessage({
    required this.target,
    required this.recoverableDeleteDate,
  });

  @override
  int get hashCode => target.hashCode ^ recoverableDeleteDate.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MoveToRecycleBinMessage &&
          runtimeType == other.runtimeType &&
          target == other.target &&
          recoverableDeleteDate == other.recoverableDeleteDate;
}

class MyAsyncRuntime {
  const MyAsyncRuntime();

  static Future<MyAsyncRuntime> default_() =>
      RustLib.instance.api.crateApiApiMyAsyncRuntimeDefault();

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MyAsyncRuntime && runtimeType == other.runtimeType;
}

class NormalMessage {
  MessageParts parts;
  String? effect;
  String? replyGuid;
  String? replyPart;
  final MessageType service;
  String? subject;
  ExtensionApp? app;
  LinkMeta? linkMeta;
  bool voice;
  ScheduleMode? scheduled;
  ShareProfileMessage? embeddedProfile;

  NormalMessage({
    required this.parts,
    this.effect,
    this.replyGuid,
    this.replyPart,
    required this.service,
    this.subject,
    this.app,
    this.linkMeta,
    required this.voice,
    this.scheduled,
    this.embeddedProfile,
  });

  @override
  int get hashCode =>
      parts.hashCode ^
      effect.hashCode ^
      replyGuid.hashCode ^
      replyPart.hashCode ^
      service.hashCode ^
      subject.hashCode ^
      app.hashCode ^
      linkMeta.hashCode ^
      voice.hashCode ^
      scheduled.hashCode ^
      embeddedProfile.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NormalMessage &&
          runtimeType == other.runtimeType &&
          parts == other.parts &&
          effect == other.effect &&
          replyGuid == other.replyGuid &&
          replyPart == other.replyPart &&
          service == other.service &&
          subject == other.subject &&
          app == other.app &&
          linkMeta == other.linkMeta &&
          voice == other.voice &&
          scheduled == other.scheduled &&
          embeddedProfile == other.embeddedProfile;
}

enum NSDictionaryClass {
  nsDictionary,
  nsMutableDictionary,
  ;
}

class NSURL {
  final String base;
  final String relative;

  const NSURL({
    required this.base,
    required this.relative,
  });

  @override
  int get hashCode => base.hashCode ^ relative.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NSURL &&
          runtimeType == other.runtimeType &&
          base == other.base &&
          relative == other.relative;
}

class OperatedChat {
  final List<String> participants;
  final String groupId;
  final String guid;
  final bool? deleteIncomingMessages;
  final bool? wasReportedAsJunk;

  const OperatedChat({
    required this.participants,
    required this.groupId,
    required this.guid,
    this.deleteIncomingMessages,
    this.wasReportedAsJunk,
  });

  @override
  int get hashCode =>
      participants.hashCode ^
      groupId.hashCode ^
      guid.hashCode ^
      deleteIncomingMessages.hashCode ^
      wasReportedAsJunk.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OperatedChat &&
          runtimeType == other.runtimeType &&
          participants == other.participants &&
          groupId == other.groupId &&
          guid == other.guid &&
          deleteIncomingMessages == other.deleteIncomingMessages &&
          wasReportedAsJunk == other.wasReportedAsJunk;
}

@freezed
sealed class PartExtension with _$PartExtension {
  const PartExtension._();

  const factory PartExtension.sticker({
    required double msgWidth,
    required double rotation,
    required BigInt sai,
    required double scale,
    bool? update,
    required BigInt sli,
    required double normalizedX,
    required double normalizedY,
    required BigInt version,
    required String hash,
    required BigInt safi,
    required PlatformInt64 effectType,
    required String stickerId,
  }) = PartExtension_Sticker;
}

class PermanentDeleteMessage {
  final DeleteTarget target;
  final bool isScheduled;

  const PermanentDeleteMessage({
    required this.target,
    required this.isScheduled,
  });

  @override
  int get hashCode => target.hashCode ^ isScheduled.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PermanentDeleteMessage &&
          runtimeType == other.runtimeType &&
          target == other.target &&
          isScheduled == other.isScheduled;
}

@freezed
sealed class PollResult with _$PollResult {
  const PollResult._();

  const factory PollResult.stop() = PollResult_Stop;
  const factory PollResult.cont([
    PushMessage? field0,
  ]) = PollResult_Cont;
}

class PrivateDeviceInfo {
  final String? uuid;
  final String? deviceName;
  final Uint8List token;
  final bool isHsaTrusted;
  final List<String> identites;
  final List<String> subServices;

  const PrivateDeviceInfo({
    this.uuid,
    this.deviceName,
    required this.token,
    required this.isHsaTrusted,
    required this.identites,
    required this.subServices,
  });

  @override
  int get hashCode =>
      uuid.hashCode ^
      deviceName.hashCode ^
      token.hashCode ^
      isHsaTrusted.hashCode ^
      identites.hashCode ^
      subServices.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrivateDeviceInfo &&
          runtimeType == other.runtimeType &&
          uuid == other.uuid &&
          deviceName == other.deviceName &&
          token == other.token &&
          isHsaTrusted == other.isHsaTrusted &&
          identites == other.identites &&
          subServices == other.subServices;
}

@freezed
sealed class PushMessage with _$PushMessage {
  const PushMessage._();

  const factory PushMessage.iMessage(
    MessageInst field0,
  ) = PushMessage_IMessage;
  const factory PushMessage.sendConfirm({
    required String uuid,
    String? error,
  }) = PushMessage_SendConfirm;
  const factory PushMessage.registrationState(
    RegisterState field0,
  ) = PushMessage_RegistrationState;
  const factory PushMessage.newPhotostream(
    SharedAlbum field0,
  ) = PushMessage_NewPhotostream;
  const factory PushMessage.faceTime(
    FTMessage field0,
  ) = PushMessage_FaceTime;
}

class ReactMessage {
  final String toUuid;
  final int? toPart;
  final ReactMessageType reaction;
  final String toText;
  final ShareProfileMessage? embeddedProfile;

  const ReactMessage({
    required this.toUuid,
    this.toPart,
    required this.reaction,
    required this.toText,
    this.embeddedProfile,
  });

  @override
  int get hashCode =>
      toUuid.hashCode ^
      toPart.hashCode ^
      reaction.hashCode ^
      toText.hashCode ^
      embeddedProfile.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReactMessage &&
          runtimeType == other.runtimeType &&
          toUuid == other.toUuid &&
          toPart == other.toPart &&
          reaction == other.reaction &&
          toText == other.toText &&
          embeddedProfile == other.embeddedProfile;
}

@freezed
sealed class ReactMessageType with _$ReactMessageType {
  const ReactMessageType._();

  const factory ReactMessageType.react({
    required Reaction reaction,
    required bool enable,
  }) = ReactMessageType_React;
  const factory ReactMessageType.extension_({
    required ExtensionApp spec,
    required MessageParts body,
  }) = ReactMessageType_Extension;
}

@freezed
sealed class Reaction with _$Reaction {
  const Reaction._();

  const factory Reaction.heart() = Reaction_Heart;
  const factory Reaction.like() = Reaction_Like;
  const factory Reaction.dislike() = Reaction_Dislike;
  const factory Reaction.laugh() = Reaction_Laugh;
  const factory Reaction.emphasize() = Reaction_Emphasize;
  const factory Reaction.question() = Reaction_Question;
  const factory Reaction.emoji(
    String field0,
  ) = Reaction_Emoji;
  const factory Reaction.sticker({
    ExtensionApp? spec,
    required MessageParts body,
  }) = Reaction_Sticker;
}

@freezed
sealed class RegisterState with _$RegisterState {
  const RegisterState._();

  const factory RegisterState.registered({
    required PlatformInt64 nextS,
  }) = RegisterState_Registered;
  const factory RegisterState.registering() = RegisterState_Registering;
  const factory RegisterState.failed({
    BigInt? retryWait,
    required String error,
  }) = RegisterState_Failed;
}

enum RegistrationPhase {
  wantsOsConfig,
  wantsRegister,
  registered,
  ;
}

class RenameMessage {
  final String newName;

  const RenameMessage({
    required this.newName,
  });

  @override
  int get hashCode => newName.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RenameMessage &&
          runtimeType == other.runtimeType &&
          newName == other.newName;
}

class RichLinkImageAttachmentSubstitute {
  final String mimeType;
  final BigInt richLinkImageAttachmentSubstituteIndex;

  const RichLinkImageAttachmentSubstitute({
    required this.mimeType,
    required this.richLinkImageAttachmentSubstituteIndex,
  });

  @override
  int get hashCode =>
      mimeType.hashCode ^ richLinkImageAttachmentSubstituteIndex.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RichLinkImageAttachmentSubstitute &&
          runtimeType == other.runtimeType &&
          mimeType == other.mimeType &&
          richLinkImageAttachmentSubstituteIndex ==
              other.richLinkImageAttachmentSubstituteIndex;
}

class ScheduleMode {
  final int ms;
  final bool schedule;

  const ScheduleMode({
    required this.ms,
    required this.schedule,
  });

  @override
  int get hashCode => ms.hashCode ^ schedule.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ScheduleMode &&
          runtimeType == other.runtimeType &&
          ms == other.ms &&
          schedule == other.schedule;
}

class ShareProfileMessage {
  final Uint8List cloudKitDecryptionRecordKey;
  final String cloudKitRecordKey;
  final SharedPoster? poster;

  const ShareProfileMessage({
    required this.cloudKitDecryptionRecordKey,
    required this.cloudKitRecordKey,
    this.poster,
  });

  @override
  int get hashCode =>
      cloudKitDecryptionRecordKey.hashCode ^
      cloudKitRecordKey.hashCode ^
      poster.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ShareProfileMessage &&
          runtimeType == other.runtimeType &&
          cloudKitDecryptionRecordKey == other.cloudKitDecryptionRecordKey &&
          cloudKitRecordKey == other.cloudKitRecordKey &&
          poster == other.poster;
}

class SharedAlbum {
  final String? name;
  final String? fullname;
  final String? email;
  final String albumguid;
  final String sharingtype;
  final String? subscriptiondate;
  final String? albumlocation;
  final List<String> assets;
  final String? delete;

  const SharedAlbum({
    this.name,
    this.fullname,
    this.email,
    required this.albumguid,
    required this.sharingtype,
    this.subscriptiondate,
    this.albumlocation,
    required this.assets,
    this.delete,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      fullname.hashCode ^
      email.hashCode ^
      albumguid.hashCode ^
      sharingtype.hashCode ^
      subscriptiondate.hashCode ^
      albumlocation.hashCode ^
      assets.hashCode ^
      delete.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SharedAlbum &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          fullname == other.fullname &&
          email == other.email &&
          albumguid == other.albumguid &&
          sharingtype == other.sharingtype &&
          subscriptiondate == other.subscriptiondate &&
          albumlocation == other.albumlocation &&
          assets == other.assets &&
          delete == other.delete;
}

class SharedPoster {
  final Uint8List lowResWallpaperTag;
  final Uint8List wallpaperTag;
  final Uint8List messageTag;

  const SharedPoster({
    required this.lowResWallpaperTag,
    required this.wallpaperTag,
    required this.messageTag,
  });

  @override
  int get hashCode =>
      lowResWallpaperTag.hashCode ^ wallpaperTag.hashCode ^ messageTag.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SharedPoster &&
          runtimeType == other.runtimeType &&
          lowResWallpaperTag == other.lowResWallpaperTag &&
          wallpaperTag == other.wallpaperTag &&
          messageTag == other.messageTag;
}

class SupportAction {
  final String url;
  final String button;

  const SupportAction({
    required this.url,
    required this.button,
  });

  @override
  int get hashCode => url.hashCode ^ button.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SupportAction &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          button == other.button;
}

class SupportAlert {
  final String title;
  final String body;
  final SupportAction? action;

  const SupportAlert({
    required this.title,
    required this.body,
    this.action,
  });

  @override
  int get hashCode => title.hashCode ^ body.hashCode ^ action.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SupportAlert &&
          runtimeType == other.runtimeType &&
          title == other.title &&
          body == other.body &&
          action == other.action;
}

@freezed
sealed class SyncStatus with _$SyncStatus {
  const SyncStatus._();

  const factory SyncStatus.synced() = SyncStatus_Synced;
  const factory SyncStatus.downloading({
    required BigInt progress,
    required BigInt total,
  }) = SyncStatus_Downloading;
  const factory SyncStatus.uploading({
    required BigInt progress,
    required BigInt total,
  }) = SyncStatus_Uploading;
  const factory SyncStatus.syncing() = SyncStatus_Syncing;
}

enum TextEffect {
  big,
  small,
  shake,
  nod,
  explode,
  ripple,
  bloom,
  jitter,
  ;
}

class TextFlags {
  final bool bold;
  final bool italic;
  final bool underline;
  final bool strikethrough;

  const TextFlags({
    required this.bold,
    required this.italic,
    required this.underline,
    required this.strikethrough,
  });

  @override
  int get hashCode =>
      bold.hashCode ^
      italic.hashCode ^
      underline.hashCode ^
      strikethrough.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TextFlags &&
          runtimeType == other.runtimeType &&
          bold == other.bold &&
          italic == other.italic &&
          underline == other.underline &&
          strikethrough == other.strikethrough;
}

@freezed
sealed class TextFormat with _$TextFormat {
  const TextFormat._();

  const factory TextFormat.flags(
    TextFlags field0,
  ) = TextFormat_Flags;
  const factory TextFormat.effect(
    TextEffect field0,
  ) = TextFormat_Effect;
}

class TransferProgress {
  final int prog;
  final int total;
  final Attachment? attachment;

  const TransferProgress({
    required this.prog,
    required this.total,
    this.attachment,
  });

  @override
  int get hashCode => prog.hashCode ^ total.hashCode ^ attachment.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TransferProgress &&
          runtimeType == other.runtimeType &&
          prog == other.prog &&
          total == other.total &&
          attachment == other.attachment;
}

class TrustedPhoneNumber {
  final String numberWithDialCode;
  final String lastTwoDigits;
  final String pushMode;
  final int id;

  const TrustedPhoneNumber({
    required this.numberWithDialCode,
    required this.lastTwoDigits,
    required this.pushMode,
    required this.id,
  });

  @override
  int get hashCode =>
      numberWithDialCode.hashCode ^
      lastTwoDigits.hashCode ^
      pushMode.hashCode ^
      id.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TrustedPhoneNumber &&
          runtimeType == other.runtimeType &&
          numberWithDialCode == other.numberWithDialCode &&
          lastTwoDigits == other.lastTwoDigits &&
          pushMode == other.pushMode &&
          id == other.id;
}

class UnsendMessage {
  final String tuuid;
  final int editPart;

  const UnsendMessage({
    required this.tuuid,
    required this.editPart,
  });

  @override
  int get hashCode => tuuid.hashCode ^ editPart.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UnsendMessage &&
          runtimeType == other.runtimeType &&
          tuuid == other.tuuid &&
          editPart == other.editPart;
}

class UpdateExtensionMessage {
  final String forUuid;
  final PartExtension ext;

  const UpdateExtensionMessage({
    required this.forUuid,
    required this.ext,
  });

  @override
  int get hashCode => forUuid.hashCode ^ ext.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UpdateExtensionMessage &&
          runtimeType == other.runtimeType &&
          forUuid == other.forUuid &&
          ext == other.ext;
}

class UpdateProfileMessage {
  final ShareProfileMessage? profile;
  final bool shareContacts;

  const UpdateProfileMessage({
    this.profile,
    required this.shareContacts,
  });

  @override
  int get hashCode => profile.hashCode ^ shareContacts.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UpdateProfileMessage &&
          runtimeType == other.runtimeType &&
          profile == other.profile &&
          shareContacts == other.shareContacts;
}

class UpdateProfileSharingMessage {
  final List<String> sharedDismissed;
  final List<String> sharedAll;
  final int version;

  const UpdateProfileSharingMessage({
    required this.sharedDismissed,
    required this.sharedAll,
    required this.version,
  });

  @override
  int get hashCode =>
      sharedDismissed.hashCode ^ sharedAll.hashCode ^ version.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UpdateProfileSharingMessage &&
          runtimeType == other.runtimeType &&
          sharedDismissed == other.sharedDismissed &&
          sharedAll == other.sharedAll &&
          version == other.version;
}
